<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuhui | 刘辉</title>
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hui-liu.github.io/"/>
  <updated>2017-03-15T14:30:08.579Z</updated>
  <id>https://hui-liu.github.io/</id>
  
  <author>
    <name>Hui Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>networkx 笔记</title>
    <link href="https://hui-liu.github.io/2017-03-15-networkx-%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hui-liu.github.io/2017-03-15-networkx-笔记.html</id>
    <published>2017-03-15T14:12:24.000Z</published>
    <updated>2017-03-15T14:30:08.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NetworkX-复杂网络分析笔记"><a href="#NetworkX-复杂网络分析笔记" class="headerlink" title="NetworkX 复杂网络分析笔记"></a>NetworkX 复杂网络分析笔记</h1><p>主要参考<a href="http://blog.sciencenet.cn/blog-404069-337442.html" target="_blank" rel="external">1</a>，<a href="http://glowingpython.blogspot.jp/2013/02/betweenness-centrality.html" target="_blank" rel="external">2</a>，<a href="https://blog.dominodatalab.com/social-network-analysis-with-networkx/" target="_blank" rel="external">3</a></p>
<h2 id="1-建图"><a href="#1-建图" class="headerlink" title="1. 建图"></a>1. 建图</h2><p>networkx可以建立简单无向图graph，有向图digraph，可重复边的multi-graph。</p>
<h3 id="1-1-简单无向图-graph"><a href="#1-1-简单无向图-graph" class="headerlink" title="1.1 简单无向图 graph"></a>1.1 简单无向图 graph</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="comment">#建立一个空的无向图G</span></div><div class="line">G=nx.Graph()</div><div class="line"><span class="comment">#添加一个节点1</span></div><div class="line">G.add_node(<span class="number">1</span>)</div><div class="line"><span class="comment">#添加一条边2-3（隐含着添加了两个节点2、3）</span></div><div class="line">G.add_edge(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">#对于无向图，边3-2与边2-3被认为是一条边</span></div><div class="line">G.add_edge(<span class="number">3</span>,<span class="number">2</span>)</div><div class="line"><span class="comment">#输出全部的节点： [1, 2, 3]</span></div><div class="line"><span class="keyword">print</span> G.nodes()</div><div class="line"><span class="comment">#输出全部的边：[(2, 3)]</span></div><div class="line"><span class="keyword">print</span> G.edges()</div><div class="line"><span class="comment">#输出边的数量：1</span></div><div class="line"><span class="keyword">print</span> G.number_of_edges()</div><div class="line"><span class="comment">#输出点数</span></div><div class="line"><span class="keyword">print</span> g.number_of_nodes()</div></pre></td></tr></table></figure>
<h3 id="1-2-有向图-digraph"><a href="#1-2-有向图-digraph" class="headerlink" title="1.2 有向图 digraph"></a>1.2 有向图 digraph</h3><p>有向图的建立方式和无向图基本类似，只是在上述代码的第二行，将<code>G = nx.Graph()</code> 改为 <code>G = nx.DiGraph()</code> 。需要注意的是，此时再添加边<code>3-2</code>与边<code>2-3</code>，则被认为是两条不同的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line">D=nx.DiGraph()</div></pre></td></tr></table></figure>
<blockquote>
<p>同时，有向图和无向图是可以相互转化的，分别用到Graph.to_undirected() 和 Graph.to_directed()两个方法。</p>
</blockquote>
<h3 id="1-3-加权图"><a href="#1-3-加权图" class="headerlink" title="1.3 加权图"></a>1.3 加权图</h3><p>有向图和无向图都可以给边赋予权重，用到的方法是<code>add_weighted_edges_from</code>，它接受1个或多个三元组[u,v,w]作为参数，其中u是起点，v是终点，w是权重。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 添加0-1、1-2和2-3三条边，权重分别是3.0和7.5</span></div><div class="line">G.add_weighted_edges_from([(<span class="number">0</span>,<span class="number">1</span>,<span class="number">3.0</span>),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">7.5</span>),(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1.0</span>)])</div><div class="line"><span class="comment"># 如果想读取权重，可以使用get_edge_data方法，它接受两个参数u和v，即边的起始点。</span></div><div class="line"><span class="keyword">print</span> G.get_edge_data(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="comment"># 选出边的权重超过一个阈值的边</span></div><div class="line">estrong = [(u,v) <span class="keyword">for</span> (u,v,d) <span class="keyword">in</span> G.edges(data=<span class="keyword">True</span>) <span class="keyword">if</span> d[<span class="string">"weight"</span>] &gt; <span class="number">3.0</span>]</div><div class="line"><span class="keyword">print</span> estrong <span class="comment"># [(1, 2)]</span></div></pre></td></tr></table></figure>
<p>这是一个加权图的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> use</div><div class="line">use(<span class="string">"Agg"</span>)</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line"></div><div class="line">df = pd.read_csv(<span class="string">"../data/relation_weight_sam.csv"</span>)</div><div class="line"></div><div class="line">G = nx.from_pandas_dataframe(df, </div><div class="line">                              <span class="string">'node1'</span>, </div><div class="line">                              <span class="string">'node2'</span>, </div><div class="line">                               edge_attr=<span class="string">'weight'</span></div><div class="line">                              )</div><div class="line"></div><div class="line"><span class="comment"># saves the positions of the nodes on the visualization</span></div><div class="line"><span class="comment"># In detail positions is a dictionary where each node is</span></div><div class="line"><span class="comment"># a key and the value is a position on the graph</span></div><div class="line"><span class="comment"># &#123;'Fam38a_predicted': array([ 0.52246857,  0.4412573 ], dtype=float32),...&#125;</span></div><div class="line">positions = nx.spring_layout(G)</div><div class="line"></div><div class="line"><span class="comment"># pass positions and set hold=True</span></div><div class="line">nx.draw(G, pos=positions, hold=<span class="keyword">True</span>, with_labels=<span class="keyword">False</span>, node_size=<span class="number">30</span>)</div><div class="line"></div><div class="line">weights = [w[<span class="number">2</span>][<span class="string">'weight'</span>]*<span class="number">5</span> <span class="keyword">for</span> w <span class="keyword">in</span>  G.edges(data=<span class="keyword">True</span>)]</div><div class="line"><span class="comment">#width can be array of floats</span></div><div class="line">nx.draw_networkx_edges(G, pos=positions, width=weights)</div><div class="line"></div><div class="line">plt.savefig(<span class="string">"../output/net_weight.png"</span>)</div><div class="line"><span class="comment"># 前十行数据，weight是通过"numpy.random.rand()"模拟的。</span></div><div class="line"><span class="string">"""</span></div><div class="line">node1   node2   weight</div><div class="line">Ablim2  Acsl6   0.0656480910603</div><div class="line">Ablim2  Apeg1   0.0727940253706</div><div class="line">Ablim2  Atp2a2  0.5280955211</div><div class="line">Ablim2  Boll_predicted  0.200347948345</div><div class="line">Ablim2  Cap2    0.108700562945</div><div class="line">Ablim2  Copb1   0.546335670525</div><div class="line">Ablim2  Creld2  0.420412397031</div><div class="line">Ablim2  Dtna_predicted  0.24546480993</div><div class="line">Ablim2  Dusp8_predicted 0.932345236242</div><div class="line">"""</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\net_weight.png" alt="net_weight"></p>
<h3 id="1-4-可重复边的-multi-graph"><a href="#1-4-可重复边的-multi-graph" class="headerlink" title="1.4 可重复边的 multi-graph"></a>1.4 可重复边的 multi-graph</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line">M=nx.MultiGraph()</div></pre></td></tr></table></figure>
<h3 id="1-5-点"><a href="#1-5-点" class="headerlink" title="1.5 点"></a>1.5 点</h3><p>这里的点可以是任意可区分的对象（hashable），比如数字，字符串，对象等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">G.add_node(<span class="number">1</span>)</div><div class="line">G.add_node(<span class="string">'first_node'</span>)</div><div class="line"><span class="comment">#这里用一个对象多为key来唯一区别一个点</span></div><div class="line"><span class="comment">#我们还能够用一个列表来批量加入点</span></div><div class="line">G.add_nodes_from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line"><span class="comment">#还可以用一个图对象作为点，嵌入到其他图中</span></div><div class="line">G.add_node(D) <span class="comment">#这里D作为一个点的key</span></div><div class="line"><span class="comment">#或者把一个图的所有点赋予另一个图</span></div><div class="line">G.add_nodes_from(D) <span class="comment">#这里返回D的所有点，赋予G</span></div><div class="line"><span class="comment">#与加入相同的传递方法，我们也可以删除点</span></div><div class="line">G.remove_node(<span class="number">1</span>)</div><div class="line">G.remove_nodes_from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure>
<h3 id="1-6-边"><a href="#1-6-边" class="headerlink" title="1.6 边"></a>1.6 边</h3><p>这里的边可以使用两个单独的对象作为输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">G.add_edge(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#表示1，2之间有一条边。</span></div><div class="line"><span class="comment">#如果不存在点1，2，则会自动加入点集合。</span></div><div class="line"><span class="comment">#或者以元组的形式作为输入</span></div><div class="line">e=(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">G.add_edge(*e)</div><div class="line"><span class="comment">#这里的*代表吧元组解包（unpack），当作一个个的值扔到函数中去。</span></div><div class="line"><span class="comment">#如果不解包，等价于</span></div><div class="line"><span class="comment">#G.add_edge(e)=G.add_edge((1,2))与参数传递的方式不符。</span></div><div class="line"><span class="comment">#类似的，我们还可以使用包含元组的列表来传递参数</span></div><div class="line">G.add_edges_from([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>)])</div><div class="line"><span class="comment">#我们还可以报一个图的边赋予另一个图</span></div><div class="line">G.add_edges_from(H)</div><div class="line"><span class="comment">#删除</span></div><div class="line">G.remove_edge(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">G.remove_edges_from([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>)])</div></pre></td></tr></table></figure>
<h3 id="1-7-访问"><a href="#1-7-访问" class="headerlink" title="1.7 访问"></a>1.7 访问</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">node_list = G.nodes()</div><div class="line">edge_list = G.edges()</div><div class="line"><span class="comment">#可以返回包含点与边的列表</span></div><div class="line">node = G.node[‘first_node’]</div><div class="line"><span class="comment">#如上根据key返回点</span></div><div class="line">edge = G.edge[<span class="string">'first_node'</span>][<span class="string">'second_node'</span>]</div><div class="line"><span class="comment">#同样的方法，返回两个key之间的边</span></div></pre></td></tr></table></figure>
<h3 id="1-8-属性"><a href="#1-8-属性" class="headerlink" title="1.8 属性"></a>1.8 属性</h3><p>我们可以给图，点，边赋予各种属性，最简单的就是权值属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">G.add_node(<span class="number">1</span>,time=<span class="string">'5pm'</span>)</div><div class="line"><span class="comment">#在添加时跟上属性</span></div><div class="line">G.add_nodes_from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],time=<span class="string">'5pm'</span>)</div><div class="line"><span class="comment">#批量添加点是，跟上统一的属性</span></div><div class="line">G.add_nodes_from([(<span class="number">3</span>,&#123;<span class="string">'time'</span>:<span class="string">'5pm'</span>&#125;), (<span class="number">4</span>,&#123;<span class="string">'time'</span>:<span class="string">'4pm'</span>&#125;)])</div><div class="line"><span class="comment">#或者写成元组列表[（key,dict），（key,dict）]的形式</span></div><div class="line">G.node[<span class="number">1</span>][<span class="string">'time'</span>]</div><div class="line"><span class="comment">#根据字典key访问属性值。</span></div><div class="line"></div><div class="line"><span class="comment">#给边添加属性也类似</span></div><div class="line">G.add_edge(<span class="number">1</span>,<span class="number">2</span>,time=<span class="string">'3am'</span>)</div><div class="line">G.add_edges_from([(<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="string">'time'</span>=<span class="string">'5pm'</span>&#125;),(<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="string">'time'</span>=<span class="number">3</span>am&#125;)])</div><div class="line"><span class="comment">#批量赋予属性</span></div><div class="line">G.edge[<span class="number">1</span>][<span class="number">2</span>][‘time’]</div><div class="line"><span class="comment">#访问</span></div><div class="line"></div><div class="line"><span class="comment">#我们还可以使用特定的函数批量返回属性，如</span></div><div class="line">time = nx.get_edge_attributes(G,<span class="string">'time'</span>)</div><div class="line"><span class="comment">#返回得到以元组为key,time属性为值得一个字典</span></div><div class="line">time[(<span class="number">1</span>,<span class="number">2</span>)]</div></pre></td></tr></table></figure>
<h3 id="1-9-图算法"><a href="#1-9-图算法" class="headerlink" title="1.9 图算法"></a>1.9 图算法</h3><p>NetworkX提供了常用的图论经典算法，例如DFS、BFS、最短路、最小生成树、最大流等等，非常丰富，如果不做复杂网络，只作图论方面的工作，也可以应用NetworkX作为基本的开发包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#调用多源最短路径算法，计算图G所有节点间的最短路径</span></div><div class="line">path=nx.all_pairs_shortest_path(G)</div><div class="line"><span class="comment">#输出节点0、2之间的最短路径序列： [0, 1, 2]</span></div><div class="line"><span class="keyword">print</span> path[<span class="number">0</span>][<span class="number">2</span>]</div></pre></td></tr></table></figure>
<h3 id="1-10-画图"><a href="#1-10-画图" class="headerlink" title="1.10 画图"></a>1.10 画图</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">nx.draw(G) <span class="comment"># 方法，至少接受一个参数：待绘制的网络G </span></div><div class="line">matplotlib.show() <span class="comment">#显示出来</span></div></pre></td></tr></table></figure>
<h4 id="画图参数"><a href="#画图参数" class="headerlink" title="画图参数"></a>画图参数</h4><h5 id="运行样式"><a href="#运行样式" class="headerlink" title="运行样式"></a>运行样式</h5><ul>
<li><code>node_size</code>:  指定节点的尺寸大小(默认是300)<ul>
<li><code>node_color</code>:  指定节点的颜色 (默认是红色，可以用字符串简单标识颜色，例如’r’为红色，’b’为绿色等)</li>
<li><code>node_shape</code>:  节点的形状（默认是圆形，用字符串’o’标识）</li>
<li><code>alpha</code>: 透明度 (默认是1.0，不透明，0为完全透明) </li>
<li><code>width</code>: 边的宽度 (默认为1.0)</li>
<li><code>edge_color</code>: 边的颜色(默认为黑色)</li>
<li><code>style</code>: 边的样式(默认为实现，可选： solid|dashed|dotted,dashdot)</li>
<li><code>with_labels</code>: 节点是否带标签（默认为True）</li>
<li><code>font_size</code>: 节点标签字体大小 (默认为12)</li>
<li><code>font_color</code>: 节点标签字体颜色（默认为黑色）</li>
</ul>
</li>
</ul>
<h5 id="运用布局"><a href="#运用布局" class="headerlink" title="运用布局"></a>运用布局</h5><p>　　<code>circular_layout</code>：节点在一个圆环上均匀分布<br>　　<code>random_layout</code>：节点随机分布<br>　　<code>shell_layout</code>：节点在同心圆上分布<br>　　<code>spring_layout</code>： 用Fruchterman-Reingold算法排列节点（样子类似多中心放射状）<br>　　<code>spectral_layout</code>：根据图的拉普拉斯特征向量排列节点</p>
<h5 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h5><p>　　用plt.title()方法可以为图形添加一个标题，该方法接受一个字符串作为参数。</p>
<p>　　fontsize参数用来指定标题的大小。例如：plt.title(“BA Networks”, fontsize = 20)。</p>
<p>　　如果要在任意位置添加文本，则可以采用plt.text()方法。</p>
<h2 id="2-四种网络模型"><a href="#2-四种网络模型" class="headerlink" title="2. 四种网络模型"></a>2. 四种网络模型</h2><p>NetworkX提供了4种常见网络的建模方法，分别是：规则图，ER随机图，WS小世界网络和BA无标度网络。</p>
<h3 id="2-1-规则图"><a href="#2-1-规则图" class="headerlink" title="2.1 规则图"></a>2.1 规则图</h3><p>规则图差不多是最没有复杂性的一类图，<code>random_graphs.random_regular_graph(d, n)</code>方法可以生成一个含有n个节点，每个节点有d个邻居节点的规则图。</p>
<p>　　下面一段示例代码，生成了包含20个节点、每个节点有3个邻居的规则图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># regular graphy</span></div><div class="line"><span class="comment"># generate a regular graph which has 20 nodes &amp; each node has 3 neghbour nodes.</span></div><div class="line">RG = nx.random_graphs.random_regular_graph(<span class="number">3</span>, <span class="number">20</span>)</div><div class="line"><span class="comment"># the spectral layout</span></div><div class="line">pos = nx.spectral_layout(RG)</div><div class="line"><span class="comment"># draw the regular graphy</span></div><div class="line">nx.draw(RG, pos, with_labels = <span class="keyword">False</span>, node_size = <span class="number">30</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\规则图.png" alt="规则图"></p>
<h3 id="2-2-ER随机图"><a href="#2-2-ER随机图" class="headerlink" title="2.2 ER随机图"></a>2.2 ER随机图</h3><p>ER随机图是早期研究得比较多的一类“复杂”网络，模型的基本思想是以概率p连接N个节点中的每一对节点。用<code>random_graphs.erdos_renyi_graph(n,p)</code>方法生成一个含有n个节点、以概率p连接的ER随机图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># erdos renyi graph</span></div><div class="line"><span class="comment"># generate a graph which has n=20 nodes, probablity p = 0.2.</span></div><div class="line">ER = nx.random_graphs.erdos_renyi_graph(<span class="number">20</span>, <span class="number">0.2</span>)</div><div class="line"><span class="comment"># the shell layout</span></div><div class="line">pos = nx.shell_layout(ER)</div><div class="line">nx.draw(ER, pos, with_labels = <span class="keyword">False</span>, node_size = <span class="number">30</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\ER.png" alt="ER"></p>
<h3 id="2-3-WS小世界网络"><a href="#2-3-WS小世界网络" class="headerlink" title="2.3 WS小世界网络"></a>2.3 WS小世界网络</h3><p>　　用<code>random_graphs.watts_strogatz_graph(n, k, p)</code>方法生成一个含有n个节点、每个节点有k个邻居、以概率p随机化重连边的WS小世界网络。</p>
<p>　　下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># WS network</span></div><div class="line"></div><div class="line"><span class="comment"># generate a WS network which has 20 nodes,</span></div><div class="line"><span class="comment"># each node has 4 neighbour nodes,</span></div><div class="line"><span class="comment"># random reconnection probability was 0.3.</span></div><div class="line">WS = nx.random_graphs.watts_strogatz_graph(<span class="number">20</span>, <span class="number">4</span>, <span class="number">0.3</span>)</div><div class="line"><span class="comment"># circular layout</span></div><div class="line">pos = nx.circular_layout(WS)</div><div class="line">nx.draw(WS, pos, with_labels = <span class="keyword">False</span>, node_size = <span class="number">30</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\WG.png" alt="WG"></p>
<h3 id="2-4-BA无标度网络"><a href="#2-4-BA无标度网络" class="headerlink" title="2.4 BA无标度网络"></a>2.4 BA无标度网络</h3><p>用<code>random_graphs.barabasi_albert_graph(n, m)</code>方法生成一个含有n个节点、每次加入m条边的BA无标度网络。</p>
<p>下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># BA scale-free degree network</span></div><div class="line"><span class="comment"># generalize BA network which has 20 nodes, m = 1</span></div><div class="line">BA = nx.random_graphs.barabasi_albert_graph(<span class="number">20</span>, <span class="number">1</span>)</div><div class="line"><span class="comment"># spring layout</span></div><div class="line">pos = nx.spring_layout(BA)</div><div class="line">nx.draw(BA, pos, with_labels = <span class="keyword">False</span>, node_size = <span class="number">30</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\BA.png" alt="BA"></p>
<p><strong>对BA模型实现代码的分析</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">#定义一个方法，它有两个参数：n - 网络节点数量；m - 每步演化加入的边数量</span></div><div class="line">def barabasi_albert_graph(n, m):</div><div class="line">    <span class="comment"># 生成一个包含m个节点的空图 (即BA模型中t=0时的m0个节点) </span></div><div class="line">    G=empty_graph(m)  </div><div class="line">    <span class="comment"># 定义新加入边要连接的m个目标节点</span></div><div class="line">    targets=range(m)  </div><div class="line">    <span class="comment"># 将现有节点按正比于其度的次数加入到一个数组中，初始化时的m个节点度均为0，所以数组为空 </span></div><div class="line">    repeated_nodes=[]     </div><div class="line">    <span class="comment"># 添加其余的 n-m 个节点，第一个节点编号为m（Python的数组编号从0开始）</span></div><div class="line">    <span class="built_in">source</span>=m </div><div class="line">    <span class="comment"># 循环添加节点</span></div><div class="line">    <span class="keyword">while</span> <span class="built_in">source</span>&lt;n: </div><div class="line">        <span class="comment"># 从源节点连接m条边到选定的m个节点targets上（注意targets是上一步生成的）</span></div><div class="line">        G.add_edges_from(zip([<span class="built_in">source</span>]*m,targets)) </div><div class="line">        <span class="comment"># 对于每个被选择的节点，将它们加入到repeated_nodes数组中（它们的度增加了1）</span></div><div class="line">        repeated_nodes.extend(targets)</div><div class="line">        <span class="comment"># 将源点m次加入到repeated_nodes数组中（它的度增加了m）</span></div><div class="line">        repeated_nodes.extend([<span class="built_in">source</span>]*m) </div><div class="line">        <span class="comment"># 从现有节点中选取m个节点 ，按正比于度的概率（即度优先连接）</span></div><div class="line">        targets=<span class="built_in">set</span>()</div><div class="line">        <span class="keyword">while</span> len(targets)&lt;m:</div><div class="line">            <span class="comment">#按正比于度的概率随机选择一个节点，见注释1</span></div><div class="line">            x=random.choice(repeated_nodes) </div><div class="line">            <span class="comment">#将其添加到目标节点数组targets中</span></div><div class="line">            targets.add(x)        </div><div class="line">        <span class="comment">#挑选下一个源点，转到循环开始，直到达到给定的节点数n</span></div><div class="line">        <span class="built_in">source</span> += 1 </div><div class="line">    <span class="comment">#返回所得的图G</span></div><div class="line">    <span class="built_in">return</span> G</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">from matplotlib import <span class="keyword">use</span></div><div class="line"><span class="keyword">use</span>(<span class="string">"Agg"</span>)</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">from</span> networkx.generators.classic <span class="keyword">import</span> empty_graph</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="keyword">def</span> barabasi_albert_graph(n, m):</div><div class="line">    G=empty_graph(m)  </div><div class="line">    targets=<span class="keyword">range</span>(m)  </div><div class="line">    repeated_nodes=[]     </div><div class="line">    <span class="keyword">source</span>=m </div><div class="line">    <span class="keyword">while</span> <span class="keyword">source</span>&lt;n: </div><div class="line">        G.add_edges_from(zip([<span class="keyword">source</span>]*m,targets)) </div><div class="line">        repeated_nodes.extend(targets)</div><div class="line">        repeated_nodes.extend([<span class="keyword">source</span>]*m) </div><div class="line">        targets=<span class="keyword">set</span>()</div><div class="line">        <span class="keyword">while</span> <span class="keyword">len</span>(targets)&lt;m:</div><div class="line">            x=random.choice(repeated_nodes) </div><div class="line">            targets.add(x)        </div><div class="line">        <span class="keyword">source</span> += <span class="number">1</span> </div><div class="line">    <span class="keyword">return</span> G</div><div class="line">	</div><div class="line">#</div><div class="line">#G=nx.Graph()</div><div class="line">G = barabasi_albert_graph(<span class="number">400</span>,<span class="number">6</span>)</div><div class="line">pos = nx.spring_layout(G)</div><div class="line">nx.draw(G, pos, with_labels = <span class="literal">False</span>, node_size = <span class="number">30</span>)</div><div class="line">plt.savefig(<span class="string">"../output/BA_400_6.png"</span>)</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\BA_400_6.png" alt="BA_400_6"></p>
<h2 id="3-统计指标计算"><a href="#3-统计指标计算" class="headerlink" title="3. 统计指标计算"></a>3. 统计指标计算</h2><h3 id="3-1-度、度分布"><a href="#3-1-度、度分布" class="headerlink" title="3.1 度、度分布"></a>3.1 度、度分布</h3><p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\dgree.jpg" alt="dgree"></p>
<p>NetworkX可以用来统计图中每个节点的度，并生成度分布序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"> <span class="comment">#生成一个n=1000，m=3的BA无标度网络</span></div><div class="line">G = nx.random_graphs.barabasi_albert_graph(<span class="number">1000</span>,<span class="number">3</span>)</div><div class="line"><span class="comment">#返回某个节点的度</span></div><div class="line"><span class="keyword">print</span> G.degree(<span class="number">0</span>)</div><div class="line"><span class="comment">#返回所有节点的度</span></div><div class="line"><span class="keyword">print</span> G.degree()</div><div class="line"><span class="comment">#返回图中所有节点的度分布序列（从1至最大度的出现频次）</span></div><div class="line"><span class="keyword">print</span> nx.degree_histogram(G)</div><div class="line"><span class="comment">#返回图中所有节点的度分布序列</span></div><div class="line">degree =  nx.degree_histogram(G)</div><div class="line"><span class="comment">#生成x轴序列，从1到最大度</span></div><div class="line">x = range(len(degree))</div><div class="line"><span class="comment">#将频次转换为频率</span></div><div class="line">y = [z / float(sum(degree)) <span class="keyword">for</span> z <span class="keyword">in</span> degree]</div><div class="line"><span class="comment">#在双对数坐标轴上绘制度分布曲线</span></div><div class="line">plt.loglog(x,y,color=<span class="string">"blue"</span>,linewidth=<span class="number">2</span>)</div><div class="line"><span class="comment">#显示图表</span></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\degree_dis.png" alt="degree_dis"></p>
<h3 id="3-2-群聚系数"><a href="#3-2-群聚系数" class="headerlink" title="3.2 群聚系数"></a>3.2 群聚系数</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 平均群聚系数</span></div><div class="line">nx.average_clustering(G)</div><div class="line"><span class="comment"># 各个节点的群聚系数</span></div><div class="line">nx.clustering(G)</div></pre></td></tr></table></figure>
<h3 id="3-3-直径和平均距离"><a href="#3-3-直径和平均距离" class="headerlink" title="3.3 直径和平均距离"></a>3.3 直径和平均距离</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 图G的直径（最长最短路径的长度）</span></div><div class="line">nx.diameter(G)</div><div class="line"><span class="comment"># 图G所有节点间平均最短路径长度</span></div><div class="line">nx.average_shortest_path_length(G)</div></pre></td></tr></table></figure>
<h3 id="3-4-中心性"><a href="#3-4-中心性" class="headerlink" title="3.4 中心性"></a>3.4 <a href="https://en.wikipedia.org/wiki/Centrality" target="_blank" rel="external">中心性</a></h3><p>一个图的直径是所有点之间最长的最短路径。<br>在连接中心度，我们需要寻找一个点，这个点出现在很多点的最短路径中。出现的次数越多，连接中心性越高。这样的点，可以作为一个桥梁作用。<br>意义：分析该节点对网络信息流动的影响，如：考察此人的社交能力或对于社会网络中信息流动的影响力。</p>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\betweenness centrality.jpg" alt="betweenness centrality"></p>
<h4 id="betweenness-centrality"><a href="#betweenness-centrality" class="headerlink" title="betweenness centrality"></a>betweenness centrality</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">G=nx.Graph()</div><div class="line"><span class="keyword">print</span> G.edges() <span class="comment"># []</span></div><div class="line">G.add_edges_from([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">6</span>)])</div><div class="line"><span class="keyword">print</span> G.edges()</div><div class="line"><span class="comment">#[(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (2, 5), (3, 5), (4, 6)]</span></div><div class="line"><span class="comment"># betweenness centrality</span></div><div class="line">bc = nx.betweenness_centrality(G)</div><div class="line"><span class="keyword">print</span> sorted(bc.items(), key=<span class="keyword">lambda</span> k: k[<span class="number">1</span>], reverse=<span class="keyword">True</span>)</div><div class="line"><span class="comment"># [(4, 0.4), (2, 0.35000000000000003), (1, 0.1), (3, 0.05), (5, 0.0), (6, 0.0)]</span></div><div class="line"><span class="comment"># spring layout</span></div><div class="line">pos = nx.spring_layout(G)</div><div class="line">nx.draw(G, pos, with_labels = <span class="keyword">True</span>, node_size = <span class="number">100</span>,font_size=<span class="number">6</span>,font_color=<span class="string">'b'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\BC.png" alt="BC"></p>
<p>另一个复杂的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> community</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="comment"># Exploratory Data Analysis</span></div><div class="line"><span class="comment"># data</span></div><div class="line">df = pd.read_csv(sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment">#node1 = list(df["node1"])</span></div><div class="line"></div><div class="line">G = nx.from_pandas_dataframe(df, </div><div class="line">                              <span class="string">'node1'</span>, </div><div class="line">                              <span class="string">'node2'</span>, </div><div class="line">                               <span class="comment">#edge_attr='weight',</span></div><div class="line">                               <span class="comment">#create_using=nx.MultiGraph()</span></div><div class="line">                              )</div><div class="line"><span class="comment">#Quick snapshot of the Network</span></div><div class="line"><span class="keyword">print</span> nx.info(G)</div><div class="line"></div><div class="line"><span class="comment">#Create network layout for visualizations</span></div><div class="line">spring_pos = nx.spring_layout(G)</div><div class="line"></div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">most_important</span><span class="params">(G)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    returns a copy of G with</div><div class="line">    the most important nodes</div><div class="line">    according to the pagerank</div><div class="line">    """ </div><div class="line"></div><div class="line">    ranking = nx.betweenness_centrality(G).items()</div><div class="line">    <span class="comment">#print ranking</span></div><div class="line">    r = [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> ranking]</div><div class="line">    m = sum(r)/len(r) <span class="comment"># mean centrality</span></div><div class="line">    t = m*<span class="number">10</span> <span class="comment"># threshold, we keep only the nodes with 10 times the mean</span></div><div class="line">    Gt = G.copy()</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> ranking:</div><div class="line">        <span class="keyword">if</span> v &lt; t:</div><div class="line">            Gt.remove_node(k)</div><div class="line">    <span class="keyword">return</span> Gt</div><div class="line"></div><div class="line">Gt = most_important(G) <span class="comment"># trimming</span></div><div class="line"></div><div class="line"><span class="comment"># draw the nodes and the edges (all)</span></div><div class="line">nx.draw_networkx_nodes(G,spring_pos,node_color=<span class="string">'b'</span>,alpha=<span class="number">0.2</span>,node_size=<span class="number">8</span>)</div><div class="line">nx.draw_networkx_edges(G,spring_pos,alpha=<span class="number">0.1</span>)</div><div class="line"></div><div class="line"><span class="comment"># draw the most important nodes with a different style</span></div><div class="line">nx.draw_networkx_nodes(Gt,spring_pos,node_color=<span class="string">'r'</span>,alpha=<span class="number">0.4</span>,node_size=<span class="number">254</span>)</div><div class="line"><span class="comment"># also the labels this time</span></div><div class="line">nx.draw_networkx_labels(Gt,spring_pos,font_size=<span class="number">6</span>,font_color=<span class="string">'b'</span>)</div><div class="line">plt.savefig(<span class="string">"../output/FB_BetCen.png"</span>, dpi = <span class="number">300</span>)</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\FB_BetCen.png" alt="FB_BetCen"></p>
<h2 id="4-社区发现（Community-detection）"><a href="#4-社区发现（Community-detection）" class="headerlink" title="4. 社区发现（Community detection）"></a>4. 社区发现（Community detection）</h2><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> community</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="comment"># Exploratory Data Analysis</span></div><div class="line"><span class="comment"># data</span></div><div class="line">df = pd.read_csv(sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment">#node1 = list(df["node1"])</span></div><div class="line"></div><div class="line">G = nx.from_pandas_dataframe(df, </div><div class="line">                              <span class="string">'node1'</span>, </div><div class="line">                              <span class="string">'node2'</span>, </div><div class="line">                               <span class="comment">#edge_attr='weight',</span></div><div class="line">                               <span class="comment">#create_using=nx.MultiGraph()</span></div><div class="line">                              )</div><div class="line"><span class="comment">#Quick snapshot of the Network</span></div><div class="line"><span class="keyword">print</span> nx.info(G)</div><div class="line"></div><div class="line"><span class="comment">#Create network layout for visualizations</span></div><div class="line">spring_pos = nx.spring_layout(G)</div><div class="line"></div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line"><span class="comment">#</span></div><div class="line">part = community.best_partition(G)</div><div class="line">values = [part.get(node) <span class="keyword">for</span> node <span class="keyword">in</span> G.nodes()]</div><div class="line"></div><div class="line">nx.draw_spring(G, cmap = plt.get_cmap(<span class="string">'jet'</span>), node_color = values, node_size=<span class="number">30</span>, with_labels=<span class="keyword">False</span>)</div><div class="line">plt.savefig(<span class="string">"../output/FB_commu.png"</span>, dpi = <span class="number">300</span>)</div><div class="line"><span class="comment">#  get modularity</span></div><div class="line">mod = community.modularity(part,G)</div><div class="line">print(<span class="string">"modularity:"</span>, mod)</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\FB_commu.png" alt="FB_commu"></p>
<p>也可以在<code>betweenness centrality</code>的基础上画<code>community detection</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> community</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="comment"># Exploratory Data Analysis</span></div><div class="line"><span class="comment"># data</span></div><div class="line">df = pd.read_csv(sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment">#node1 = list(df["node1"])</span></div><div class="line"></div><div class="line">G = nx.from_pandas_dataframe(df, </div><div class="line">                              <span class="string">'node1'</span>, </div><div class="line">                              <span class="string">'node2'</span>, </div><div class="line">                               <span class="comment">#edge_attr='weight',</span></div><div class="line">                               <span class="comment">#create_using=nx.MultiGraph()</span></div><div class="line">                              )</div><div class="line"><span class="comment">#Quick snapshot of the Network</span></div><div class="line"><span class="keyword">print</span> nx.info(G)</div><div class="line"></div><div class="line"><span class="comment">#Create network layout for visualizations</span></div><div class="line">spring_pos = nx.spring_layout(G)</div><div class="line"></div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">most_important</span><span class="params">(G)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    returns a copy of G with</div><div class="line">    the most important nodes</div><div class="line">    according to the pagerank</div><div class="line">    """ </div><div class="line"></div><div class="line">    ranking = nx.betweenness_centrality(G).items()</div><div class="line">    <span class="comment">#print ranking</span></div><div class="line">    r = [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> ranking]</div><div class="line">    m = sum(r)/len(r) <span class="comment"># mean centrality</span></div><div class="line">    t = m*<span class="number">10</span> <span class="comment"># threshold, we keep only the nodes with 10 times the mean</span></div><div class="line">    Gt = G.copy()</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> ranking:</div><div class="line">        <span class="keyword">if</span> v &lt; t:</div><div class="line">            Gt.remove_node(k)</div><div class="line">    <span class="keyword">return</span> Gt</div><div class="line"></div><div class="line">Gt = most_important(G) <span class="comment"># trimming</span></div><div class="line"></div><div class="line"><span class="comment"># draw the nodes and the edges (all)</span></div><div class="line">nx.draw_networkx_nodes(G,spring_pos,node_color=<span class="string">'b'</span>,alpha=<span class="number">0.2</span>,node_size=<span class="number">8</span>)</div><div class="line">nx.draw_networkx_edges(G,spring_pos,alpha=<span class="number">0.1</span>)</div><div class="line"></div><div class="line"><span class="comment"># draw the most important nodes with a different style</span></div><div class="line">nx.draw_networkx_nodes(Gt,spring_pos,node_color=<span class="string">'r'</span>,alpha=<span class="number">0.4</span>,node_size=<span class="number">254</span>)</div><div class="line"><span class="comment"># also the labels this time</span></div><div class="line">nx.draw_networkx_labels(Gt,spring_pos,font_size=<span class="number">6</span>,font_color=<span class="string">'b'</span>)</div><div class="line"></div><div class="line"><span class="comment">#</span></div><div class="line">part = community.best_partition(G)</div><div class="line">values = [part.get(node) <span class="keyword">for</span> node <span class="keyword">in</span> G.nodes()]</div><div class="line"></div><div class="line">nx.draw_networkx(G, pos = spring_pos, cmap = plt.get_cmap(<span class="string">'jet'</span>), node_color = values, node_size=<span class="number">30</span>, with_labels=<span class="keyword">False</span>)</div><div class="line">plt.savefig(<span class="string">"../output/FB_BC_commu.png"</span>, dpi = <span class="number">300</span>)</div><div class="line"><span class="comment">#  get modularity</span></div><div class="line">mod = community.modularity(part,G)</div><div class="line">print(<span class="string">"modularity:"</span>, mod)</div></pre></td></tr></table></figure>
<p><img src="/C:/liuhui\WD\Blog\blog\source\_posts\networkx-笔记\FB_BC_commu.png" alt="FB_BC_commu"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NetworkX-复杂网络分析笔记&quot;&gt;&lt;a href=&quot;#NetworkX-复杂网络分析笔记&quot; class=&quot;headerlink&quot; title=&quot;NetworkX 复杂网络分析笔记&quot;&gt;&lt;/a&gt;NetworkX 复杂网络分析笔记&lt;/h1&gt;&lt;p&gt;主要参考&lt;a hre
    
    </summary>
    
      <category term="notes" scheme="https://hui-liu.github.io/categories/notes/"/>
    
    
      <category term="python" scheme="https://hui-liu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>如何在遍历时，正确删除列表中的 items</title>
    <link href="https://hui-liu.github.io/2017-03-08-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%81%8D%E5%8E%86%E6%97%B6%EF%BC%8C%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84-items.html"/>
    <id>https://hui-liu.github.io/2017-03-08-如何在遍历时，正确删除列表中的-items.html</id>
    <published>2017-03-08T09:21:23.000Z</published>
    <updated>2017-03-08T09:22:48.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误的代码"><a href="#错误的代码" class="headerlink" title="错误的代码"></a>错误的代码</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">x = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line">y = [<span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> x:</div><div class="line">    <span class="keyword">if</span> <span class="selector-tag">i</span> <span class="keyword">in</span> y:</div><div class="line">        x.remove(i)</div><div class="line">print x</div><div class="line">-----------------</div><div class="line"></div><div class="line">[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div></pre></td></tr></table></figure>
<h3 id="正确的代码"><a href="#正确的代码" class="headerlink" title="正确的代码"></a>正确的代码</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">x = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line">y = [<span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> x[:]:</div><div class="line">    <span class="keyword">if</span> <span class="selector-tag">i</span> <span class="keyword">in</span> y:</div><div class="line">        x.remove(i)</div><div class="line">print x</div><div class="line">-----------------</div><div class="line"></div><div class="line">[<span class="string">'a'</span>, <span class="string">'d'</span>]</div></pre></td></tr></table></figure>
<p>实际上，<code>id(x)</code>与<code>id(x[:])</code>是不同的，所以只有在<code>x</code>的副本（<code>x[:]</code>）中遍历，然后在<code>x</code>中删除，才不会造成错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;错误的代码&quot;&gt;&lt;a href=&quot;#错误的代码&quot; class=&quot;headerlink&quot; title=&quot;错误的代码&quot;&gt;&lt;/a&gt;错误的代码&lt;/h3&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;
    
    </summary>
    
      <category term="code" scheme="https://hui-liu.github.io/categories/code/"/>
    
    
      <category term="python" scheme="https://hui-liu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>根据一个list文件生成一个组合</title>
    <link href="https://hui-liu.github.io/2017-03-05-%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AAlist%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%BB%84%E5%90%88.html"/>
    <id>https://hui-liu.github.io/2017-03-05-根据一个list文件生成一个组合.html</id>
    <published>2017-03-05T08:35:07.000Z</published>
    <updated>2017-03-05T08:50:52.091Z</updated>
    
    <content type="html"><![CDATA[<p>假设有一个 list 如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">$ cat aa</div><div class="line"><span class="selector-tag">a</span></div><div class="line"><span class="selector-tag">b</span></div><div class="line">c</div><div class="line">d</div></pre></td></tr></table></figure>
<p>期望生成如下组合：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">a</span>       <span class="selector-tag">b</span></div><div class="line"><span class="selector-tag">a</span>       c</div><div class="line"><span class="selector-tag">a</span>       d</div><div class="line"><span class="selector-tag">b</span>       c</div><div class="line"><span class="selector-tag">b</span>       d</div><div class="line">c       d</div></pre></td></tr></table></figure>
<p>实现方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">set</span> -- $(cat <span class="variable">$1</span>) <span class="comment"># 将输入文件的每一行依次赋值给位置变量，如第一行赋值给 $1，第二行给 $2。。。</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $* <span class="comment"># $* 为所有位置变量的 list</span></div><div class="line"><span class="keyword">do</span></div><div class="line"><span class="built_in">shift</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> $*</div><div class="line">    <span class="keyword">do</span></div><div class="line">    <span class="built_in">printf</span> <span class="string">"%s\t%s\n"</span> <span class="string">"<span class="variable">$i</span>"</span> <span class="string">"<span class="variable">$j</span>"</span></div><div class="line">    <span class="keyword">done</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">$ ./pair_combination<span class="selector-class">.sh</span> aa</div><div class="line"><span class="selector-tag">a</span>       <span class="selector-tag">b</span></div><div class="line"><span class="selector-tag">a</span>       c</div><div class="line"><span class="selector-tag">a</span>       d</div><div class="line"><span class="selector-tag">b</span>       c</div><div class="line"><span class="selector-tag">b</span>       d</div><div class="line">c       d</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设有一个 list 如下：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ cat aa&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;s
    
    </summary>
    
      <category term="linux" scheme="https://hui-liu.github.io/categories/linux/"/>
    
    
      <category term="linux shell" scheme="https://hui-liu.github.io/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>Detecting pervasive positive selection step by step</title>
    <link href="https://hui-liu.github.io/2017-03-02-Detecting-pervasive-positive-selection.html"/>
    <id>https://hui-liu.github.io/2017-03-02-Detecting-pervasive-positive-selection.html</id>
    <published>2017-03-02T09:01:33.000Z</published>
    <updated>2017-03-03T14:03:45.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Site-model-assumsing-that-the-dn-ds-rato-is-the-same-across-branches-but-different-between-sites"><a href="#Site-model-assumsing-that-the-dn-ds-rato-is-the-same-across-branches-but-different-between-sites" class="headerlink" title="Site-model: assumsing that the dn/ds rato is the same across branches, but different between sites"></a>Site-model: assumsing that the dn/ds rato is the same across branches, but different between sites</h3><h4 id="1-multiple-sequence-alignment"><a href="#1-multiple-sequence-alignment" class="headerlink" title="(1) multiple sequence alignment"></a>(1) multiple sequence alignment</h4><ul>
<li>speed: muscle &gt; mafft &gt; clustalW &gt; T-Coffee</li>
<li>accuracy: mafft &gt; muscle &gt; T-Coffee &gt; clustalW</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">cd /home/liuhui/nature_selection/exemple/data_for_codeml</div><div class="line">mafft-linsi ../input/HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.fasta</span> &gt; HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.fasta</span></div></pre></td></tr></table></figure>
<h4 id="2-convert-protein-alignment-to-cds-alignment"><a href="#2-convert-protein-alignment-to-cds-alignment" class="headerlink" title="(2) convert protein alignment to cds alignment"></a>(2) convert protein alignment to cds alignment</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">perl /home/liuhui/nature_selection/exemple/bin/pepMfa_to_cdsMfa<span class="selector-class">.pl</span> HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.fasta</span> ../input/HLA_DQB1<span class="selector-class">.cds</span><span class="selector-class">.fasta</span> &gt; HLA_DQB1<span class="selector-class">.cds</span><span class="selector-class">.mafft</span><span class="selector-class">.fasta</span></div></pre></td></tr></table></figure>
<h4 id="3-Remove-spurious-sequences-and-columns"><a href="#3-Remove-spurious-sequences-and-columns" class="headerlink" title="(3) Remove spurious sequences and columns"></a>(3) Remove spurious sequences and columns</h4><ul>
<li>aa sequences  (construct gene tree)</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">trimal -automated1 -<span class="keyword">in</span> HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.fasta</span> -out HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.trimal</span><span class="selector-class">.fasta</span> -htmlout HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.trimal</span><span class="selector-class">.html</span> -colnumbering &gt; HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.trimal</span><span class="selector-class">.cols</span></div></pre></td></tr></table></figure>
<ul>
<li>cds sequences (for codeml)</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">python /home/liuhui/nature_selection/bin/MSA_triplets_gaps_removed<span class="selector-class">.py</span> HLA_DQB1<span class="selector-class">.cds</span><span class="selector-class">.mafft</span><span class="selector-class">.fasta</span> HLA_DQB1<span class="selector-class">.cds</span><span class="selector-class">.mafft_removed_trigaps</span><span class="selector-class">.fasta</span></div></pre></td></tr></table></figure>
<h4 id="4-convert-fasta-to-phylip-format"><a href="#4-convert-fasta-to-phylip-format" class="headerlink" title="(4) convert fasta to phylip format"></a>(4) convert fasta to phylip format</h4><figure class="highlight awk"><table><tr><td class="code"><pre><div class="line"><span class="regexp">/home/</span>liuhui<span class="regexp">/nature_selection/</span>exemple<span class="regexp">/bin/</span>convert_fasta2phylip.py HLA_DQB1.aa.mafft.trimal.fasta HLA_DQB1.aa.mafft.trimal.phy <span class="comment"># construct tree</span></div><div class="line"><span class="regexp">/home/</span>liuhui<span class="regexp">/nature_selection/</span>exemple<span class="regexp">/bin/</span>convert_fasta2phylip.py HLA_DQB1.cds.mafft_removed_trigaps.fasta HLA_DQB1.cds.mafft_removed_trigaps.phy <span class="comment"># for codeml</span></div></pre></td></tr></table></figure>
<h4 id="5-construct-tree"><a href="#5-construct-tree" class="headerlink" title="(5) construct tree"></a>(5) construct tree</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">phyml -<span class="selector-tag">i</span> HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.trimal</span><span class="selector-class">.phy</span> -<span class="selector-tag">q</span> -d aa -m JTT -c <span class="number">4</span> -<span class="selector-tag">a</span> e</div><div class="line">sed <span class="string">'s/\()\)[0-9]\.[^:]*:/\1:/g'</span> HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.trimal</span><span class="selector-class">.phy_phyml_tree</span><span class="selector-class">.txt</span> &gt; HLA_DQB1<span class="selector-class">.aa</span><span class="selector-class">.mafft</span><span class="selector-class">.trimal</span><span class="selector-class">.tree</span></div></pre></td></tr></table></figure>
<h4 id="6-codeml"><a href="#6-codeml" class="headerlink" title="(6) codeml"></a>(6) codeml</h4><figure class="highlight awk"><table><tr><td class="code"><pre><div class="line"><span class="comment"># M0M1M2M3M7M8</span></div><div class="line">cd <span class="regexp">/home/</span>liuhui<span class="regexp">/nature_selection/</span>exemple<span class="regexp">/output/</span></div><div class="line">mkdir HLA_DQB1_M0M1M2M3M7M8</div><div class="line">cd HLA_DQB1_M0M1M2M3M7M8</div><div class="line">codeml HLA_DQB1_M0M1M2M3M7M8.ctl</div><div class="line"></div><div class="line"><span class="comment"># M8a</span></div><div class="line">cd <span class="regexp">/home/</span>liuhui<span class="regexp">/nature_selection/</span>exemple<span class="regexp">/output/</span></div><div class="line">mkdir HLA_DQB1_M8a</div><div class="line">cd HLA_DQB1_M8a</div><div class="line">codeml HLA_DQB1_M8a.ctl</div></pre></td></tr></table></figure>
<h4 id="7-significant-test"><a href="#7-significant-test" class="headerlink" title="(7) significant test"></a>(7) significant test</h4><ul>
<li>np: the number of parameters</li>
<li>lnL: log-likelihood value</li>
<li>LRT: likelihood-ratio test</li>
</ul>
<p>Model_compared  Model0  np0     lnL0    Model1  np1     lnL1    df      LRT     pvalue<br>M7-M8   M7      44      -5047.785978    M8      46      -5011.936805    2       71.6983 2.69719269066922e-16<br>M0-M3   M0      43      -5214.976615    M3      47      -5011.542624    4       406.868 9.12618975872726e-87<br>M8-M8a  M8a     45      -5031.655392    M8      46      -5011.936805    1       39.4372 3.38781154892534e-10<br>M1a-M2a M1a     44      -5036.170805    M2a     46      -5014.302814    2       43.736  3.18308524710324e-10</p>
<h4 id="8-identification-of-sites"><a href="#8-identification-of-sites" class="headerlink" title="(8) identification of sites"></a>(8) identification of sites</h4><h5 id="M2a"><a href="#M2a" class="headerlink" title="M2a"></a>M2a</h5><blockquote>
<p>Bayes Empirical Bayes (BEB) analysis (Yang, Wong &amp; Nielsen 2005. Mol. Biol. Evol. 22:1107-1118)<br>Positively selected sites (<em>: P&gt;95%; *</em>: P&gt;99%)<br>(amino acids refer to 1st sequence: ENSP00000364080)</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line">         Pr(w&gt;<span class="number">1</span>)     post mean +- SE <span class="keyword">for</span> w</div><div class="line"> <span class="number">38</span> <span class="literal">F</span>      <span class="number">0.938</span>         <span class="number">3.258</span> +- <span class="number">0.761</span></div><div class="line"> <span class="number">55</span> L      <span class="number">0.999</span>**       <span class="number">3.408</span> +- <span class="number">0.518</span></div><div class="line"> <span class="number">66</span> Y      <span class="number">0.837</span>         <span class="number">2.994</span> +- <span class="number">0.991</span></div><div class="line"> <span class="number">86</span> D      <span class="number">0.997</span>**       <span class="number">3.404</span> +- <span class="number">0.527</span></div><div class="line"> <span class="number">99</span> G      <span class="number">0.978</span>*        <span class="number">3.356</span> +- <span class="number">0.615</span></div><div class="line"> <span class="number">99</span> G      <span class="number">0.978</span>*        <span class="number">3.356</span> +- <span class="number">0.615</span></div><div class="line"><span class="number">116</span> <span class="literal">F</span>      <span class="number">0.935</span>         <span class="number">3.243</span> +- <span class="number">0.766</span></div><div class="line"><span class="number">118</span> G      <span class="number">0.662</span>         <span class="number">2.542</span> +- <span class="number">1.171</span></div><div class="line"><span class="number">123</span> R      <span class="number">0.690</span>         <span class="number">2.646</span> +- <span class="number">1.182</span></div><div class="line"><span class="number">256</span> P      <span class="number">0.998</span>**       <span class="number">3.406</span> +- <span class="number">0.523</span></div><div class="line"><span class="number">257</span> Q      <span class="number">0.864</span>         <span class="number">3.073</span> +- <span class="number">0.947</span></div><div class="line"><span class="number">258</span> G      <span class="number">0.968</span>*        <span class="number">3.334</span> +- <span class="number">0.659</span></div><div class="line"><span class="number">259</span> P      <span class="number">0.776</span>         <span class="number">2.838</span> +- <span class="number">1.079</span></div><div class="line"><span class="number">260</span> P      <span class="number">0.971</span>*        <span class="number">3.342</span> +- <span class="number">0.644</span></div></pre></td></tr></table></figure>
<h5 id="M8"><a href="#M8" class="headerlink" title="M8"></a>M8</h5><blockquote>
<p>Bayes Empirical Bayes (BEB) analysis (Yang, Wong &amp; Nielsen 2005. Mol. Biol. Evol. 22:1107-1118)<br>Positively selected sites (<em>: P&gt;95%; *</em>: P&gt;99%)<br>(amino acids refer to 1st sequence: ENSP00000364080)</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line">         Pr(w&gt;<span class="number">1</span>)     post mean +- SE <span class="keyword">for</span> w</div><div class="line"> <span class="number">14</span> <span class="literal">T</span>      <span class="number">0.539</span>         <span class="number">1.770</span> +- <span class="number">1.006</span></div><div class="line"> <span class="number">38</span> <span class="literal">F</span>      <span class="number">0.985</span>*        <span class="number">2.688</span> +- <span class="number">0.473</span></div><div class="line"> <span class="number">42</span> G      <span class="number">0.649</span>         <span class="number">1.992</span> +- <span class="number">0.956</span></div><div class="line"> <span class="number">55</span> L      <span class="number">1.000</span>**       <span class="number">2.715</span> +- <span class="number">0.417</span></div><div class="line"> <span class="number">66</span> Y      <span class="number">0.962</span>*        <span class="number">2.641</span> +- <span class="number">0.547</span></div><div class="line"> <span class="number">86</span> D      <span class="number">0.999</span>**       <span class="number">2.714</span> +- <span class="number">0.419</span></div><div class="line"> <span class="number">99</span> G      <span class="number">0.996</span>**       <span class="number">2.709</span> +- <span class="number">0.431</span></div><div class="line"><span class="number">113</span> E      <span class="number">0.518</span>         <span class="number">1.714</span> +- <span class="number">0.948</span></div><div class="line"><span class="number">116</span> <span class="literal">F</span>      <span class="number">0.989</span>*        <span class="number">2.694</span> +- <span class="number">0.459</span></div><div class="line"><span class="number">117</span> R      <span class="number">0.585</span>         <span class="number">1.855</span> +- <span class="number">0.957</span></div><div class="line"><span class="number">118</span> G      <span class="number">0.927</span>         <span class="number">2.564</span> +- <span class="number">0.632</span></div><div class="line"><span class="number">123</span> R      <span class="number">0.837</span>         <span class="number">2.393</span> +- <span class="number">0.822</span></div><div class="line"><span class="number">256</span> P      <span class="number">1.000</span>**       <span class="number">2.715</span> +- <span class="number">0.418</span></div><div class="line"><span class="number">257</span> Q      <span class="number">0.956</span>*        <span class="number">2.630</span> +- <span class="number">0.569</span></div><div class="line"><span class="number">258</span> G      <span class="number">0.992</span>**       <span class="number">2.700</span> +- <span class="number">0.451</span></div><div class="line"><span class="number">259</span> P      <span class="number">0.947</span>         <span class="number">2.609</span> +- <span class="number">0.588</span></div><div class="line"><span class="number">260</span> P      <span class="number">0.993</span>**       <span class="number">2.703</span> +- <span class="number">0.443</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Site-model-assumsing-that-the-dn-ds-rato-is-the-same-across-branches-but-different-between-sites&quot;&gt;&lt;a href=&quot;#Site-model-assumsing-tha
    
    </summary>
    
      <category term="Evolution" scheme="https://hui-liu.github.io/categories/Evolution/"/>
    
    
      <category term="positive selection" scheme="https://hui-liu.github.io/tags/positive-selection/"/>
    
  </entry>
  
  <entry>
    <title>creat a blog</title>
    <link href="https://hui-liu.github.io/2017-03-02-creat%20a%20blog.html"/>
    <id>https://hui-liu.github.io/2017-03-02-creat a blog.html</id>
    <published>2017-03-02T05:01:44.000Z</published>
    <updated>2017-03-02T14:35:25.913Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight verilog"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>. hexo <span class="keyword">new</span> <span class="string">"new blog title"</span></div><div class="line"><span class="number">2</span>. edit your text using Typora</div><div class="line"><span class="number">3</span>. hexo <span class="keyword">generate</span></div><div class="line"><span class="number">4</span>. hexo deploy</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight verilog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;. hexo &lt;span class=&quot;keywor
    
    </summary>
    
      <category term="blog" scheme="https://hui-liu.github.io/categories/blog/"/>
    
    
      <category term="notes" scheme="https://hui-liu.github.io/tags/notes/"/>
    
  </entry>
  
</feed>
